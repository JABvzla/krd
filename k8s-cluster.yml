---
# SPDX-license-identifier: Apache-2.0
##############################################################################
# Copyright (c) 2018
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Apache License, Version 2.0
# which accompanies this distribution, and is available at
# http://www.apache.org/licenses/LICENSE-2.0
##############################################################################

# Kubernetes configuration dirs and system namespace.
# Those are where all the additional config stuff goes
# kubernetes normally puts in /srv/kubernetes.
# This puts them in a sane location and namespace.
# Editing those values will almost surely break something.
system_namespace: kube-system

# Logging directory (sysvinit systems)
kube_log_dir: "/var/log/kubernetes"

kube_api_anonymous_auth: true

# Users to create for basic auth in Kubernetes API via HTTP
# Optionally add groups for user
kube_api_pwd: "secret"
kube_users:
  kube:
    pass: "{{ kube_api_pwd }}"
    role: admin
    groups:
      - system:masters

# It is possible to activate / deactivate selected authentication methods (basic auth, static token auth)
kube_basic_auth: false
kube_token_auth: false

# Choose network plugin (calico, contiv, weave or flannel)
# Can also be set to 'cloud', which lets the cloud provider setup appropriate routing
kube_network_plugin: flannel

# Make a copy of kubeconfig on the host that runs Ansible in GITDIR/artifacts
kubeconfig_localhost: true

# Change this to use another Kubernetes version, e.g. a current beta release
kube_version: v1.18.9

# Kube-proxy proxyMode configuration.
# NOTE: Ipvs is based on netfilter hook function, but uses hash table as the underlying data structure and
# works in the kernel space
# https://kubernetes.io/docs/concepts/services-networking/service/#proxy-mode-ipvs
kube_proxy_mode: iptables

# Download container images only once then push to cluster nodes in batches
download_run_once: true

# Where the binaries will be downloaded.
# Note: ensure that you've enough disk space (about 1G)
local_release_dir: "/tmp/releases"

# Helm deployment
helm_enabled: false

# Enable MountPropagation gate feature
local_volumes_enabled: true
local_volume_provisioner_enabled: true

# Makes the installer node a delegate for pushing images while running
# the deployment with ansible. This maybe the case if cluster nodes
# cannot access each over via ssh or you want to use local docker
# images as a cache for multiple clusters.
download_localhost: true

# Enable Multus
kube_network_plugin_multus: false

# Download kubectl onto the host that runs Ansible in {{ bin_dir }}
kubectl_localhost: false

# Settings for containerized control plane (etcd/kubelet/secrets)
etcd_deployment_type: docker

# Controls which platform to deploy kubelet on. Available options are host, rkt, and docker.
kubelet_deployment_type: docker

# Container for runtime
container_manager: docker

# kube_feature_gates:
#   - TopologyManager=true # Enables NUMA alignment of CPUs and peripheral devices (such as SR-IOV VFs and GPUs), allowing your workload to run in an environment optimized for low-latency.

kubelet_custom_flags:
  - "--cpu-manager-policy=static"  # Allows containers in Guaranteed pods with integer CPU requests access to exclusive CPUs on the node.

# Rook requires a FlexVolume plugin directory to integrate with K8s for performing storage operations
kubelet_flexvolumes_plugins_dir: /usr/libexec/kubernetes/kubelet-plugins/volume/exec

# Dashboard
dashboard_enabled: false
dashboard_skip_login: true

# Cert manager deployment
cert_manager_enabled: true

# Nginx ingress controller deployment
ingress_nginx_enabled: true

# Kata Containers is an OCI runtime, where containers are run inside lightweight VMs
kata_containers_enabled: false
